### 多线程间通讯
多线程之间通讯，其实就是多个线程在操作同一个资源，但是操作的动作不同。如ThreadContact.java中，输出的userInfo对象应该是交替出现的。但是使用多线程后发生了数据错乱。这是因为Productor线程对于UserInfo共享数据的操作还没有完成而Consumer线程已经去消费UserInfo共享资源。
解决这一问题的方法就是加锁。如ThreadContact1.java所示。虽然加了锁以后保证每一次输出的UserInfo的信息是正确的，但是并没有达到我们预期的两个UserInfo交替出现。这是因为虽然在两个线程中对共享变量的操作加了锁保证共享变量的原子性，但是线程的运行却没有控制，没有让生产和消费线程交替运行
这个时候就需要wait() 和 notify() 方法了。如ThreadContact2在UserInfo里面加上一个线程标志位，public boolean isConsumerNotify = true;  保证生产线程和消费线程交替进行。
### wait()、notify、notifyAll()方法
wait()、notify()、notifyAll()是三个定义在Object类里的方法，可以用来控制线程的状态。这三个方法最终调用的都是jvm级的native方法。随着jvm运行平台的不同可能有些许差异。
如果对象调用了wait方法就会使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。
如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。

注意:一定要在线程同步中使用,并且是同一个锁的资源
### wait与sleep区别?
对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。
在调用sleep()方法的过程中，线程不会释放对象锁。而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备
获取对象锁进入运行状态。

### lock锁
在 jdk1.5 之后，并发包中新增了 Lock 接口(以及相关实现类)用来实现锁功能，Lock 接口提供了与 synchronized 关键字类似的同步功能，但需要在使用时手动获取锁和释放锁.如ThreadContact3.java利用Lock和Condition进行了同步。
###### Lock 接口与 synchronized 关键字的区别
Lock 接口可以尝试非阻塞地获取锁 当前线程尝试获取锁。如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁。
Lock 接口能被中断地获取锁 与 synchronized 不同，获取到锁的线程能够响应中断，当获取到的锁的线程被中断时，中断异常将会被抛出，同时锁会被释放。
Lock 接口在指定的截止时间之前获取锁，如果截止时间到了依旧无法获取锁，则返回。

### threadLocal ThreadLocal
提供一个线程的局部变量，访问某个线程拥有自己局部变量。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。
其底层是维护了一个map集合，map的key就是当前线程，value就是当前线程所对应的局部变量。


