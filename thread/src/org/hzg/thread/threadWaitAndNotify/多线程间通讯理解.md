### 多线程间通讯
多线程之间通讯，其实就是多个线程在操作同一个资源，但是操作的动作不同。如ThreadContact.java中，输出的userInfo对象应该是交替出现的。但是使用多线程后发生了数据错乱。这是因为Productor线程对于UserInfo共享数据的操作还没有完成而Consumer线程已经去消费UserInfo共享资源。
解决这一问题的方法就是加锁。如ThreadContact1.java所示。虽然加了锁以后保证每一次输出的UserInfo的信息是正确的，但是并没有达到我们预期的两个UserInfo交替出现。这是因为虽然在两个线程中对共享变量的操作加了锁保证共享变量的原子性，但是线程的运行却没有控制，没有让生产和消费线程交替运行
这个时候就需要wait() 和 notify() 方法了。如ThreadContact2在UserInfo里面加上一个线程标志位，public boolean isConsumerNotify = true;  保证生产线程和消费线程交替进行。
### wait()、notify、notifyAll()方法
wait()、notify()、notifyAll()是三个定义在Object类里的方法，可以用来控制线程的状态。这三个方法最终调用的都是jvm级的native方法。随着jvm运行平台的不同可能有些许差异。
如果对象调用了wait方法就会使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。
如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。

注意:一定要在线程同步中使用,并且是同一个锁的资源
### wait与sleep区别?
对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。
在调用sleep()方法的过程中，线程不会释放对象锁。而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备
获取对象锁进入运行状态。


                                                                 
